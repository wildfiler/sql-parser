class SQLParser::Parser

rule
# dynamic sql

  direct_sql_statement
    : direct_sql_data_statement

  direct_sql_data_statement
    : direct_select_statement_multiple_rows
    | insert_specification
    | update_specification
    | delete_specification

  direct_select_statement_multiple_rows
    : query_expression fetch_only_clause { result = SQLParser::Statement::DirectSelect.new(val[0], val[1]) }

# module contents
  order_by_clause
    : # no action
    | ORDER BY sort_specification_list { result = SQLParser::Statement::OrderBy.new(val[2]) }

  fetch_only_clause
    : # no action
    | FETCH FIRST unsigned_integer ROWS ONLY  { result = SQLParser::Statement::FetchOnly.new(0, val[2]) }
    | OFFSET unsigned_integer ROWS FETCH NEXT unsigned_integer ROWS ONLY  { result = SQLParser::Statement::FetchOnly.new(val[1], val[5]) }

  sort_specification_list
    : sort_specification_list comma sort_specification { result = Array(val[0]) + Array(val[2]) }
    | sort_specification

  sort_specification
    : sort_key ordering_specification { result = val[1].new(val[0]) }

  sort_key
    : column_reference
    | built_in_function { result = SQLParser::Statement::BuiltInFunction.new(val[0]) }
    | unsigned_integer { result = SQLParser::Statement::Integer.new(val[0]) }

  ordering_specification
    : { result = SQLParser::Statement::Ascending } # default
    | ASC { result = SQLParser::Statement::Ascending }
    | DESC { result = SQLParser::Statement::Descending }

# queries
  subquery
    # FIXME: shortcut
    : left_paren query_expression right_paren { result = SQLParser::Statement::Subquery.new(val[1]) }

  query_expression
    : query_specification

  insert_specification
    : INSERT INTO table_reference value_list { result = SQLParser::Statement::Insert.new(val[2], nil, val[3]) }
    | INSERT INTO table_reference column_list value_list { result = SQLParser::Statement::Insert.new(val[2], val[3], val[4]) }

  update_specification
    : UPDATE table_reference SET assign_list where_clause { result = SQLParser::Statement::Update.new(val[1], val[3], val[4]) }

  delete_specification
    : DELETE FROM table_reference where_clause { result = SQLParser::Statement::Delete.new(val[2], val[3]) }

  assign_list
    : assign_column comma assign_list { result = Array(val[0]) + Array(val[2]) }
    | assign_column                   { result = Array(val[0]) }

  assign_column
    : column_name equals_operator row_value_constructor { result = SQLParser::Statement::AssignColumn.new(val[0], val[2]) }

  column_list
    : left_paren in_column_list right_paren { result = SQLParser::Statement::InColumnList.new(val[1]) }

  in_column_list
    : value_expression comma in_column_list { result = Array(val[0]) + Array(val[2]) }
	  | value_expression

  value_list
    : VALUES left_paren in_value_list right_paren { result = SQLParser::Statement::InValueList.new(val[2]) }

  query_specification
    : SELECT distinct_select_list table_expression order_by_clause limit_clause { result = SQLParser::Statement::Select.new(val[1], val[2], val[3], val[4]) }
    | SELECT distinct_select_list { result = SQLParser::Statement::Select.new(val[1]) }

  select_list
    : asterisk { result = SQLParser::Statement::All.new }
    | select_sublist { result = SQLParser::Statement::SelectList.new(val[0]) }

  distinct_select_list
    : DISTINCT select_list { result = SQLParser::Statement::Distinct.new(val[1]) }
    | select_list { result = val[0] }

  select_sublist
    : derived_column comma select_sublist { result = Array(val[0]) + Array(val[2]) }
    | derived_column

  derived_column
    : qualifier period asterisk { result = SQLParser::Statement::All.new(val[0]) }
    | value_expression AS column_name { result = SQLParser::Statement::As.new(val[0], val[2]) }
    | value_expression column_name { result = SQLParser::Statement::As.new(val[0], val[1]) }
    | value_expression

  table_expression
    : from_clause where_clause group_by_clause having_clause { result = SQLParser::Statement::TableExpression.new(val[0], val[1], val[2], val[3]) }

  from_clause
    : FROM table_reference { result = SQLParser::Statement::FromClause.new(val[1]) }

  table_reference
    : table_name AS column_name { result = SQLParser::Statement::As.new(val[0], val[2]) }
    | table_name column_name { result = SQLParser::Statement::As.new(val[0], val[1]) }
    | table_name
    | joined_table

  table_subquery
    : subquery

  joined_table
    : cross_join
    | qualified_join

  cross_join
    : table_reference comma table_name { result = SQLParser::Statement::CrossJoin.new(val[0], val[2]) }
    | table_reference CROSS JOIN table_name { result = SQLParser::Statement::CrossJoin.new(val[0], val[3]) }

  qualified_join
    : table_reference join_type JOIN table_reference join_specification { result = val[1].new(val[0], val[3], val[4]) }

  join_type
    : INNER { result = SQLParser::Statement::InnerJoin }
    | LEFT OUTER { result = SQLParser::Statement::LeftOuterJoin }
    | LEFT { result = SQLParser::Statement::LeftJoin }
    | RIGHT OUTER { result = SQLParser::Statement::RightOuterJoin }
    | RIGHT { result = SQLParser::Statement::RightJoin }
    | FULL { result = SQLParser::Statement::FullJoin }
    | FULL OUTER { result = SQLParser::Statement::FullOuterJoin }

  join_specification
    : join_condition
    | named_columns_join

  join_condition
    : ON search_condition { result = SQLParser::Statement::On.new(val[1]) }

  named_columns_join
    : USING left_paren join_column_list right_paren { result = SQLParser::Statement::Using.new(val[2]) }

  join_column_list
    : column_name_list

  where_clause
    : # no action
    | WHERE search_condition { result = SQLParser::Statement::WhereClause.new(val[1]) }

  group_by_clause
    : # no action
    | GROUP BY grouping_column_reference_list { result = SQLParser::Statement::GroupByClause.new(val[2]) }

  limit_clause
    : # no action
    | LIMIT unsigned_integer { result = SQLParser::Statement::LimitClause.new(val[1]) }

  grouping_column_reference_list
    : grouping_column_reference_list comma grouping_column_reference { result = Array(val[0]) + Array(val[2]) }
    | grouping_column_reference

  grouping_column_reference
    : column_reference

  having_clause
    : # no action
    | HAVING search_condition { result = SQLParser::Statement::HavingClause.new(val[1]) }

# query expression components
  row_subquery
    : subquery

  between_predicate
    : row_value_constructor NOT BETWEEN row_value_constructor AND row_value_constructor { result = SQLParser::Statement::Not.new(SQLParser::Statement::Between.new(val[0], val[3], val[5])) }
    | row_value_constructor BETWEEN row_value_constructor AND row_value_constructor { result = SQLParser::Statement::Between.new(val[0], val[2], val[4]) }

  in_predicate
    : row_value_constructor NOT IN in_predicate_value { result = SQLParser::Statement::Not.new(SQLParser::Statement::In.new(val[0], val[3])) }
    | row_value_constructor IN in_predicate_value { result = SQLParser::Statement::In.new(val[0], val[2]) }

  in_predicate_value
    : table_subquery
    | left_paren in_value_list right_paren { result = SQLParser::Statement::InValueList.new(Array(val[1])) }

  in_value_list
    : value_expression comma in_value_list { result = Array(val[0]) + Array(val[2]) }
    | value_expression

  like_predicate
    # FIXME: the SQL-92 grammar indicates these should be
    # character_value_expression nodes, but changing them causes reduce/reduce
    # conflicts.
    : row_value_constructor NOT LIKE row_value_constructor { result = SQLParser::Statement::Not.new(SQLParser::Statement::Like.new(val[0], val[3])) }
    | row_value_constructor LIKE row_value_constructor { result = SQLParser::Statement::Like.new(val[0], val[2]) }

  null_predicate
    : row_value_constructor IS NOT NULL { result = SQLParser::Statement::Not.new(SQLParser::Statement::Is.new(val[0], SQLParser::Statement::Null.new)) }
    | row_value_constructor IS NULL { result = SQLParser::Statement::Is.new(val[0], SQLParser::Statement::Null.new) }

  exists_predicate
    : EXISTS table_subquery { result = SQLParser::Statement::Exists.new(val[1]) }

# constraints
  table_name
    : identifier { result = SQLParser::Statement::Table.new(val[0]) }

  column_name_list
    : column_name_list comma column_name { result = Array(val[0]) + Array(val[2]) }
    | column_name

# search condition
  search_condition
    : boolean_term
    | search_condition OR boolean_term { result = SQLParser::Statement::Or.new(val[0], val[2]) }


  boolean_term
    : boolean_factor
    | boolean_term AND boolean_factor { result = SQLParser::Statement::And.new(val[0], val[2]) }
    | boolean_term XOR boolean_factor { result = SQLParser::Statement::Xor.new(val[0], val[2]) }

  boolean_factor:
    : NOT boolean_test { result = SQLParser::Statement::Not.new(val[1]) }
    | boolean_test
    | boolean_function

  boolean_test
    : boolean_primary


  boolean_primary
    : predicate
    | left_paren search_condition right_paren { result = val[1] }
    | boolean_literal 

  predicate
    : comparison_predicate
    | between_predicate
    | in_predicate
    | like_predicate
    | null_predicate
    | exists_predicate


  comparison_predicate
    : row_value_constructor equals_operator row_value_constructor { result = SQLParser::Statement::Equals.new(val[0], val[2]) }
    | row_value_constructor not_equals_operator row_value_constructor { result = SQLParser::Statement::Not.new(SQLParser::Statement::Equals.new(val[0], val[2])) }
    | row_value_constructor less_than_operator row_value_constructor { result = SQLParser::Statement::Less.new(val[0], val[2]) }
    | row_value_constructor greater_than_operator row_value_constructor { result = SQLParser::Statement::Greater.new(val[0], val[2]) }
    | row_value_constructor less_than_or_equals_operator row_value_constructor { result = SQLParser::Statement::LessOrEquals.new(val[0], val[2]) }
    | row_value_constructor greater_than_or_equals_operator row_value_constructor { result = SQLParser::Statement::GreaterOrEquals.new(val[0], val[2]) }

  row_value_constructor
    : row_value_constructor_element
    | row_subquery


  row_value_constructor_element
    : value_expression
    | general_function

  case_expression
    : CASE when_expressions END { result = SQLParser::Statement::CaseClause.new(nil,val[1], nil) } 
    | CASE when_expressions ELSE value_expression END  { result = SQLParser::Statement::CaseClause.new(nil,val[1], val[3]) }
    | CASE term when_value_expressions END { result = SQLParser::Statement::CaseClause.new(val[1], val[2], nil) }
    | CASE term when_value_expressions ELSE value_expression END { result = SQLParser::Statement::CaseClause.new(val[1], val[2], val[4]) }


  when_value_expression
   : WHEN value_expression THEN value_expression { result = SQLParser::Statement::WhenClause.new(val[1], val[3]) } 

  when_value_expressions
   : when_value_expression { result = [ val[0] ] }
   | when_value_expressions when_value_expression { result = [ *val[0], val[1] ] } 

  when_expression
   : WHEN search_condition THEN value_expression { result = SQLParser::Statement::WhenClause.new(val[1], val[3])  } 

  when_expressions
   : when_expression { result = [ val[0] ] } 
   | when_expressions when_expression { result = [ *val[0], val[1] ] }

  value_expression
    : term plus_sign value_expression { result = SQLParser::Statement::Add.new(val[0], val[2]) }
    | term minus_sign value_expression { result = SQLParser::Statement::Subtract.new(val[0], val[2]) }
    | term
    | case_expression
    | NULL { result = SQLParser::Statement::Null.new }

  term
    : factor asterisk term { result = SQLParser::Statement::Multiply.new(val[0], val[2]) }
    | factor solidus term { result = SQLParser::Statement::Divide.new(val[0], val[2]) }
    | factor

  factor
    : sign value_expression_primary { result = val[0].new(val[1]) }
    | value_expression_primary

  value_expression_primary
    : unsigned_value_specification
    | column_reference
    | set_function_specification
    | left_paren value_expression right_paren { result = val[1] }

  unsigned_value_specification
    : unsigned_literal
    | general_value_specification

  unsigned_literal
    : unsigned_numeric_literal
    | general_literal

  general_value_specification
    : CURRENT_USER { result = SQLParser::Statement::CurrentUser.new }

  column_reference
    : qualifier period column_name { result = SQLParser::Statement::QualifiedColumn.new(val[0], val[2]) }
    | column_name

  qualifier
    : table_name

  set_function_specification
    : COUNT left_paren asterisk right_paren { result = SQLParser::Statement::Count.new(SQLParser::Statement::All.new) }
    | general_set_function

  general_set_function
    : COUNT left_paren value_expression right_paren { result = SQLParser::Statement::Count.new(val[2]) }
    | AVG left_paren value_expression right_paren { result = SQLParser::Statement::Average.new(val[2]) }
    | MAX left_paren value_expression right_paren { result = SQLParser::Statement::Maximum.new(val[2]) }
    | MIN left_paren value_expression right_paren { result = SQLParser::Statement::Minimum.new(val[2]) }
    | SUM left_paren value_expression right_paren { result = SQLParser::Statement::Sum.new(val[2]) }
    | IFNULL left_paren argument_list right_paren { result = SQLParser::Statement::FunctionCall.new(val[0], val[2]) }

# arbitrary function calls
  general_function
    : identifier left_paren right_paren { result = SQLParser::Statement::FunctionCall.new(val[0], nil) }
    | identifier left_paren argument_list right_paren { result = SQLParser::Statement::FunctionCall.new(val[0], val[2]) }

  boolean_function
    : identifier left_paren argument_list right_paren { result = SQLParser::Statement::BooleanFunction.new(val[0], val[2]) }

  argument_list
    : value_expression
    | value_expression comma argument_list { result = Array(val[0]) + Array(val[2]) }

# literal numbers, strings, dates and times, booleans
  unsigned_numeric_literal
    : unsigned_integer { result = SQLParser::Statement::Integer.new(val[0]) }
    | unsigned_float {result = SQLParser::Statement::Float.new(val[0])}

  sign
    : plus_sign { result = SQLParser::Statement::UnaryPlus }
    | minus_sign { result = SQLParser::Statement::UnaryMinus }

# sql module
  column_name
    : identifier { result = SQLParser::Statement::Column.new(val[0]) }

# literals
  general_literal
    : quote character_string_literal quote { result = SQLParser::Statement::String.new(val[1]) }
    | quote quote { result = SQLParser::Statement::String.new('') }
    | datetime_literal
    | boolean_literal
    | variable { result = SQLParser::Statement::Variable.new(val[0]) }

  boolean_literal
    : true_literal { result = SQLParser::Statement::True.new }
    | false_literal { result = SQLParser::Statement::False.new }

  datetime_literal
    : date_literal

  date_literal
    : DATE date_string { result = SQLParser::Statement::Date.new(val[1]) }

   
---- header ----
require File.dirname(__FILE__) + '/parser.rex.rb'

---- inner ----

def self.parse(sql)
  new.scan_str(sql)
end
